var documenterSearchIndex = {"docs":
[{"location":"#","page":"-","title":"-","text":"#Agnostic Bayes Ensemble Documentation ","category":"page"},{"location":"#","page":"-","title":"-","text":"Overview","category":"page"},{"location":"#","page":"-","title":"-","text":"I have to thank my employer Auticon Berlin for letting me develop this package in my working time. Agnostic Bayes Ensemble is thought to be basis technology, that will be refined over time, furthermore it forms one pillar of a upcoming machine learning framework, which is supposed to consist of three broad branches: ","category":"page"},{"location":"#","page":"-","title":"-","text":"cleaning and transformation of datasets.","category":"page"},{"location":"#","page":"-","title":"-","text":"ensemble algorithms.","category":"page"},{"location":"#","page":"-","title":"-","text":"general applicable meta parameter learning.","category":"page"},{"location":"#","page":"-","title":"-","text":"There are minimal requirements regarding the installation and usage of this package. Right now, the only prerequisite is running on a machine with Julia 1.X installed. However in the upcoming releases GPU support in form of CUDA will be integrated, from there on out, CUDA-DEV-Kit will become a prerequisite.  ","category":"page"},{"location":"#","page":"-","title":"-","text":"This package has been developed to facilitate increased predictive performance, by combining raw base models in an agnostic fashion, i.e. the methods don’t use any assumption regarding the used raw models. Furthermore, we specifically implemented ensemble algorithms that can deal with arbitrary loss function and with regression and classification problems, this holds true for all, except for the dirichletPosterior estimation algorithm, which is limited to classification problems.","category":"page"},{"location":"#","page":"-","title":"-","text":"The algorithms bootstrapPosteriorEstimation, bootstrapPosteriorCorEstimation, dirichletPosteriorEstimation, TDistPosteriorEstimation infer an actual posterior distribution.","category":"page"},{"location":"#","page":"-","title":"-","text":"The algorithms  δOptimizationMSE ,   δOptimizationHinge ,  δOptimizationHingeRegularized,  δOptimizationMSERegularized do not, these algorithms are inferring mixing coefficients not required to be true probability distributuions . ","category":"page"},{"location":"#","page":"-","title":"-","text":"Hint: In most cases it is advisable to deactivate Hyperthreading for best performance. However, in some rare cases – depending on the (hardware) platform the package runs on- you will get the best performance with Hyperthreading enabled, to be sure, it is best practice to measure the performance with and without Hyperthreading.","category":"page"},{"location":"#generic-methods-1","page":"-","title":"generic methods","text":"","category":"section"},{"location":"#","page":"-","title":"-","text":"make a prediction given trained mixing coefficients and input Matrix.","category":"page"},{"location":"#","page":"-","title":"-","text":"predictEnsemble","category":"page"},{"location":"#AgnosticBayesEnsemble.predictEnsemble","page":"-","title":"AgnosticBayesEnsemble.predictEnsemble","text":"predictEnsemble( predictions::Matrix{Float64}, weights::Vector{Float64} )\n\n\n\n\nperform bayesian ensemble prediction.\n#Arguments\n- `predictions::Matrix{Float64}`: each column is the prediction of one hypothesis.\n- `weights::Vector{Float64}`:     mixing weights.\n#Return\n- `Vector{Float64}`:              prediction y.\n\n\n\n\n\npredictEnsemble( predictions::Vector{Matrix{Float64}}, weights::Vector{Float64} )\n\nperform bayesian ensemble prediction. #Arguments\n\npredictions::Vector{Matrix{Float64}}: each matrix is the prediction of one hypothesis.\nweights::Vector{Float64}:             mixing weights.\n\n#Return\n\nVector{Float64}:                      prediction y.\n\n\n\n\n\n","category":"function"},{"location":"#list-of-algorithms-1","page":"-","title":"list of algorithms","text":"","category":"section"},{"location":"#","page":"-","title":"-","text":"basic algorithm for computing a true posterior distribution using bootstrap sampling and arbitrary loss functions.","category":"page"},{"location":"#","page":"-","title":"-","text":"bootstrapPosteriorEstimation","category":"page"},{"location":"#AgnosticBayesEnsemble.bootstrapPosteriorEstimation","page":"-","title":"AgnosticBayesEnsemble.bootstrapPosteriorEstimation","text":"bootstrapPosteriorEstimation( errMat::Matrix{Float64}, samplingBatchSize::Int64, nrRuns::Int64 )\n\n\n\n\ncompute posterior p( h* = h | S ).\n#Arguments\n- `errMat::Matrix{Float64}}`: each column is the prediction error of one hypothesis.\n- `samplingBatchSize::Int64`: sample size per main iteration.\n- `nrRuns::Int64`:            number of passes over predictions.\n#Return\n- `Vector{Float64}`:          Distribution p( h* = h | S ).\n\n\n\n\n\n","category":"function"},{"location":"#","page":"-","title":"-","text":"basic algorithm for computing a true posterior distribution using bootstrap sampling and arbitrary loss functions, parameter return version.","category":"page"},{"location":"#","page":"-","title":"-","text":"bootstrapPosteriorEstimation!","category":"page"},{"location":"#AgnosticBayesEnsemble.bootstrapPosteriorEstimation!","page":"-","title":"AgnosticBayesEnsemble.bootstrapPosteriorEstimation!","text":"bootstrapPosteriorEstimation!( errMat::Matrix{Float64}, samplingBatchSize::Int64, nrRuns::Int64, p::Array{Float64} )\n\n\n\ncompute posterior p( h* = h | S ).\n#Arguments\n- `errMat::Matrix{Float64}}`: each column is the prediction error of one hypothesis.\n- `samplingBatchSize::Int64`: sample size per main iteration.\n- `nrRuns::Int64`:            number of passes over predictions.\n- `p::Vector{Float64}`:       resulting posterior p( h* = h | S ).\n#Return\n- `nothing`:                  nothing.\n\n\n\n\n\n","category":"function"},{"location":"#","page":"-","title":"-","text":"basic algorithm for computing a true posterior distribution using bootstrap sampling and the linear correlation.","category":"page"},{"location":"#","page":"-","title":"-","text":"bootstrapPosteriorCorEstimation","category":"page"},{"location":"#AgnosticBayesEnsemble.bootstrapPosteriorCorEstimation","page":"-","title":"AgnosticBayesEnsemble.bootstrapPosteriorCorEstimation","text":"bootstrapPosteriorCorEstimation( predictions::Matrix{Float64}, t::Vector{Float64}, samplingBatchSize::Int64, nrRuns::Int64 )\n\n\n\n\ncompute posterior p( h* = h | S ).\n#Arguments\n- `predictions::Matrix{Float64}`: each column is the prediction of one hypothesis.\n- `t::Vector{Float64}`:           label vector.\n- `samplingBatchSize::Int64`:     sample size per main iteration.\n- `nrRuns::Int64`:                number of main  iterations.\n#Return\n- `Vector{Float64}`:              posterior p( h* = h | S ).\n\n\n\n\n\nbootstrapPosteriorCorEstimation( predictions::Vector{Matrix{Float64}}, T::Matrix{Float64}, samplingFactor::Float64, nrRuns::Int64 )\n\n\n\n\ncompute posterior p( h* = h | S ).\n#Arguments\n- `predictions::Matrix{Float64}`: each column is the prediction of one hypothesis.\n- `T::Matrix{Float64}`:           label matrix.\n- `samplingBatchSize::Int64`:     sample size per main iteration.\n- `nrRuns::Int64`:                number of main  iterations.\n#Return\n- `Vector{Float64}`:              posterior p( h* = h | S ).\n\n\n\n\n\n","category":"function"},{"location":"#","page":"-","title":"-","text":"advanced algorithm, probabilistic inference using a dirichlatian prior.","category":"page"},{"location":"#","page":"-","title":"-","text":"dirichletPosteriorEstimation","category":"page"},{"location":"#AgnosticBayesEnsemble.dirichletPosteriorEstimation","page":"-","title":"AgnosticBayesEnsemble.dirichletPosteriorEstimation","text":"dirichletPosteriorEstimation( errMat::Matrix{Float64}, G::Matrix{Float64}, nrRuns::Int64, α_::Float64 )\n\n\n\n\ncompute posterior p( h* = h | S ).\n# Arguments\n- `errMat::Matrix{Float64}`: each column is the prediction error of one hypothesis.\n- `G::Matrix{Float64}`:      transformation matrix G.\n- `nrRuns::Int64`:           number of sampling runs.\n- `α_::Float64`:             scalar prior parameter.\n- `sampleSize::Int64`:       number of samples per run.\n# Return\n- `Vector{Float64}`:         posterior distribution\n\n\n\n\n\ndirichletPosteriorEstimation( errMat::Matrix{Float64}, nrRuns::Int64, α_::Float64 )\n\n\n\n\ncompute posterior p( h* = h | S ).\n#Arguments\n- `errMat::Matrix{Float64}`: each column is the prediction error of one hypothesis.\n- `nrRuns::Int64`:           number of main  iterations.\n- `α_::Float64`:             scalar prior parameter.\n#Return\n- `Vector{Float64}`:         posterior p( h* = h | S ).\n\n\n\n\n\n","category":"function"},{"location":"#","page":"-","title":"-","text":"advanced algorithm, probabilistic inference using a dirichlatian prior, improved performance and hardware usage under certain parameters.","category":"page"},{"location":"#","page":"-","title":"-","text":"dirichletPosteriorEstimationV2","category":"page"},{"location":"#AgnosticBayesEnsemble.dirichletPosteriorEstimationV2","page":"-","title":"AgnosticBayesEnsemble.dirichletPosteriorEstimationV2","text":"dirichletPosteriorEstimationV2( errMat::Matrix{Float64}, G::Matrix{Float64}, nrRuns::Int64, α_::Float64, sampleSize::Int64 )\n\n\n\n\ncompute posterior p( h* = h | S ), alternative version for improved performance.\n# Arguments\n- `errMat::Matrix{Float64}`: each column is the prediction error of one hypothesis.\n- `G::Matrix{Float64}`:      transformation matrix G.\n- `nrRuns::Int64`:           number of sampling runs.\n- `α_::Float64`:             scalar prior parameter.\n- `sampleSize::Int64`:       number of samples per run.\n# Return\n- `Vector{Float64}`:         posterior distribution posterior p( h* = h | S ).\n\n\n\n\n\ndirichletPosteriorEstimationV2( errMat::Matrix{Float64}, nrRuns::Int64, α_::Float64, sampleSize::Int64 )\n\n\n\n\ncompute posterior p( h* = h | S ), alternative version for improved performance.\n# Arguments\n- `errMat::Matrix{Float64}`: each column is the prediction of one hypothesis.\n- `nrRuns::Int64`:           number of sampling runs.\n- `α_::Float64`:             scalar prior parameter.\n- `sampleSize::Int64`:       number of samples per run.\n# Return\n- `Vector{Float64}`:         posterior distribution p( h* = h | S ).\n\n\n\n\n\n","category":"function"},{"location":"#","page":"-","title":"-","text":"precomputation of the transformation Matrix G, should be precomputed once, if bootstrapPosteriorCorEstimation gets called several times.","category":"page"},{"location":"#","page":"-","title":"-","text":"GMatrix","category":"page"},{"location":"#AgnosticBayesEnsemble.GMatrix","page":"-","title":"AgnosticBayesEnsemble.GMatrix","text":"GMatrix( d::Int64 )\n\n\n\n\ncompute transformation matrix G.\n#Arguments\n- `d::Int64`:        number of hypothesis used for prediction.\n#Return\n- `Matrix{Float64}`: transformation matrix G.\n\n\n\n\n\n","category":"function"},{"location":"#","page":"-","title":"-","text":"advanced algorithm, probabilistic inference using a dirichlatian prior, parameter return version.","category":"page"},{"location":"#","page":"-","title":"-","text":"dirichletPosteriorEstimation!","category":"page"},{"location":"#AgnosticBayesEnsemble.dirichletPosteriorEstimation!","page":"-","title":"AgnosticBayesEnsemble.dirichletPosteriorEstimation!","text":"dirichletPosteriorEstimation!( errMat::Matrix{Float64}, nrRuns::Int64, α_::Float64, p::Vector{Float64} )\n\n\n\n\ncompute posterior p( h* = h | S ).\n#Arguments\n- `errMat::Matrix{Float64}`: each column is the prediction error of one hypothesis.\n- `nrRuns::Int64`:           number of passes over predictions.\n- `α_::Float64`:             meta parameter value.\n- `p::Vector{Float64}`:      return value posterior p( h* = h | S ).\n#Return\n- `nothing`:                 nothing.\n\n\n\n\n\n","category":"function"},{"location":"#","page":"-","title":"-","text":"parameter search for prior parameter α.","category":"page"},{"location":"#","page":"-","title":"-","text":"metaParamSearchValidationDirichlet","category":"page"},{"location":"#AgnosticBayesEnsemble.metaParamSearchValidationDirichlet","page":"-","title":"AgnosticBayesEnsemble.metaParamSearchValidationDirichlet","text":"metaParamSearchValidationDirichlet( Y::Matrix{Float64}, t::Vector{Float64}, nrRuns::Int64, minVal::Float64, maxVal::Float64, nSteps::Int64, holdout::Float64, lossFunc )    \n\n\n\n\ncompute best α parameter regarding predictive performance.\n#Arguments\n- `Y::Matrix{Float64}`: each column is the prediction error of one hypothesis.\n- `t::Vector{Float64}`: label vector.\n- `nrRuns::Int64`:      number of passes over predictions.\n- `minVal::Float64`:    minimum value of α.\n- `maxVal::Float64`:    maximum value of α.\n- `nSteps::Int64`:      number of steps between min and max val.\n- `holdout::Float64`:   percentage used in holdout.\n- `lossFunc`:           error function handle.\n#Return\n- `Vector{Float64} x2`: α_sequence, performance_sequence.\n\n\n\n\n\n","category":"function"},{"location":"#","page":"-","title":"-","text":"advanced algorithm, probabilistic inference using a T-distribution prior.","category":"page"},{"location":"#","page":"-","title":"-","text":"TDistPosteriorEstimation","category":"page"},{"location":"#AgnosticBayesEnsemble.TDistPosteriorEstimation","page":"-","title":"AgnosticBayesEnsemble.TDistPosteriorEstimation","text":"TDistPosteriorEstimation( errMat::Matrix{Float64}, nrRuns::Int64; [κ_0::Float64=1.0] [, v_0::Float64=Float64( size( errMat, 2 ) )] [, α::Float64=0.5] [, β::Float64=0.25] )\n\n\n\n\ncompute posterior p( h* = h | S ).\n#Arguments\n- `errMat::Matrix{Float64}`:                   each column is the prediction error of one hypothesis.\n- `nrRuns::Int64`:                             number of main  iterations.\n- `κ_0::Float64=1.0`:                          regularization param.\n- `v_0::Float64=Float64( size( errMat, 2 ) )`: regularization param.\n- `α::Float64=0.5`:                            regularization param.\n- `β::Float64=0.25`:                           regularization param.\n#Return\n- `Vector{Float64}`:                           posterior p( h* = h | S ).\n\n\n\n\n\n","category":"function"},{"location":"#","page":"-","title":"-","text":"advanced algorithm, probabilistic inference using a T-distribution prior, reference algorithm.","category":"page"},{"location":"#","page":"-","title":"-","text":"TDistPosteriorEstimationReference","category":"page"},{"location":"#AgnosticBayesEnsemble.TDistPosteriorEstimationReference","page":"-","title":"AgnosticBayesEnsemble.TDistPosteriorEstimationReference","text":"TDistPosteriorEstimationReference( errMat::Matrix{Float64}, nrRuns::Int64 )\n\n\n\n\ncompute posterior p( h* = h | S ).\n#Arguments\n- `errMat::Matrix{Float64}`: each column is the prediction error of one hypothesis.\n- `nrRuns::Int64`:                number of main  iterations.\n#Return\n- `Vector{Float64}`:              posterior p( h* = h | S ).\n\n\n\n\n\n","category":"function"},{"location":"#refine-tuning-algorithms-1","page":"-","title":"refine tuning algorithms","text":"","category":"section"},{"location":"#","page":"-","title":"-","text":"given a solution for the ensemble learning problem, this method seeks to further improve the solution by refining it using unconstrainted optimization under Mean Squared Error loss function.","category":"page"},{"location":"#","page":"-","title":"-","text":"The resulting solutions aren't guaranteed to be valid probability distributions.","category":"page"},{"location":"#","page":"-","title":"-","text":"directOptimNaiveMSE","category":"page"},{"location":"#AgnosticBayesEnsemble.directOptimNaiveMSE","page":"-","title":"AgnosticBayesEnsemble.directOptimNaiveMSE","text":"directOptimNaiveMSE( predMat::Matrix{Float64}, t::Vector{Float64}, p::Vector{Float64} )\n\n\n\n\ncompute refined solution _for_ mixing parameter p.\n#Arguments\n- `predMat::Matrix{Float64}`: each column is the prediction _of_ one hypothesis.\n- `t::Vector{Float64}`:       label vector.\n- `p::Vector{Float64}`:       initial solution for mixing coefficients.\n#Return\n- `Vector{Float64}`:          improved initial solution.\n\n\n\n\n\n","category":"function"},{"location":"#","page":"-","title":"-","text":"given a solution for the ensemble learning problem, this method seeks to further improve the solution by refining it using unconstrainted optimization under Hinge loss function.","category":"page"},{"location":"#","page":"-","title":"-","text":"directOptimHinge","category":"page"},{"location":"#AgnosticBayesEnsemble.directOptimHinge","page":"-","title":"AgnosticBayesEnsemble.directOptimHinge","text":"directOptimHinge( predMat::Matrix{Float64}, t::Vector{Float64}, p::Vector{Float64} )\n\n\n\n\ncompute refined solution _for_ mixing parameter p.\n#Arguments\n- `predMat::Matrix{Float64}`: each column is the prediction _of_ one hypothesis.\n- `t::Vector{Float64}`:       label vector.\n- `p::Vector{Float64}`:       initial solution for mixing coefficients.\n#Return\n- `Vector{Float64}`:          improved initial solution.\n\n\n\n\n\n","category":"function"},{"location":"#Tutorials-1","page":"-","title":"Tutorials","text":"","category":"section"},{"location":"#","page":"-","title":"-","text":"low level Interface","category":"page"},{"location":"#","page":"-","title":"-","text":"The Interface was designed to be easy to use, therefore all parameters needed by the algorithms in the package are either y1, y2, y3, …, yk the predictions per raw model along with the label vector T, Or alternatively e1, e2, e3, …, ek the error between predicted and real labels and ground truth T. Some of the methods need additional (prior-) parameters, however this simple basic structure is consistent along all implemented ensemble methods in this package. ___","category":"page"},{"location":"#","page":"-","title":"-","text":"Examples","category":"page"},{"location":"#","page":"-","title":"-","text":"\"\"\"","category":"page"},{"location":"#","page":"-","title":"-","text":"\r\nusing AgnosticBayesEnsemble\r\nusing DataFrames\r\nusing Random\r\nusing Statistics\r\nusing StaticArrays\r\nusing Optim\r\nusing MultivariateStats\r\n\r\n\r\n\r\n#== create artificial predictions and ground truth ==#\r\nfunction distortBinaryPrediction( y::BitArray{1}, distortionFactor::Float64 )\r\n​    res          = deepcopy( y );  \r\n​    indices      = rand( 1:1:size( y, 1 ), round( Int64, distortionFactor * size( y, 1 ) ) );\r\n​    res[indices] = .!y[indices];\r\n​    return res;\r\nend  \r\n\r\nn    = 100000;\r\ny    = Bool.( rand( 0:1,n ) );\r\nyH1  = distortBinaryPrediction( y, 0.20 );\r\nyH2  = distortBinaryPrediction( y, 0.21 );\r\nyH3  = distortBinaryPrediction( y, 0.22 );\r\nyH4  = distortBinaryPrediction( y, 0.23 );\r\nyH5  = distortBinaryPrediction( y, 0.24 );\r\nyH6  = distortBinaryPrediction( y, 0.24 );\r\nyH7  = distortBinaryPrediction( y, 0.26 );\r\nyH8  = distortBinaryPrediction( y, 0.27 );\r\nyH9  = distortBinaryPrediction( y, 0.28 );\r\nyH10 = distortBinaryPrediction( y, 0.29 );\r\nyH11 = distortBinaryPrediction( y, 0.30 );\r\nyH12 = distortBinaryPrediction( y, 0.33 );\r\nyH13 = distortBinaryPrediction( y, 0.34 );\r\nyH14 = distortBinaryPrediction( y, 0.35 );\r\nyH15 = distortBinaryPrediction( y, 0.36 );\r\nyH16 = distortBinaryPrediction( y, 0.37 );\r\n\r\n#== split generated prediction set into disjoint sets eval and train==#\r\nlimit           = round( Int64, 0.7 * size( y, 1 ) );\r\npredictions     = DataFrame( h1=yH1, h2=yH2, h3=yH3, h4=yH4, h5=yH5, h6=yH6, h7=yH7, h8=yH8, h9=yH9, h10=yH10, h11=yH11, h12=yH12, h13=yH13, h14=yH14, h15=yH15, h16=yH16 );\r\npredTraining    = predictions[1:limit,:];\r\npredEval        = predictions[limit+1:end,:];\r\npredMatTraining = convert( Matrix{Float64}, predTraining );\r\npredMatEval     = convert( Matrix{Float64}, predEval );\r\nerrMatTraining  = ( repeat( Float64.( y[1:limit] ),outer = [1,size(predictions,2)] ) .- predMatTraining ).^2;\r\nerrMatTraining  = convert( Matrix{Float64}, errMatTraining );\r\nsampleSize      = 32\r\nnrRuns          = 100000\r\nα_              = 1.0\r\n\r\n#== use bootstrap correlation algorithm to estimate the model posterior  distribution ==#\r\nP = bootstrapPosteriorCorEstimation( predictions, y, sampleSize, nrRuns );\r\n\r\n#== use bootstrap algorithm to estimate the model posterior distribution ==#\r\np = bootstrapPosteriorEstimation( Matrix( errMatTraining ), sampleSize, nrRuns ); \r\n\r\n#== use Dirichletian algorithm to estimate the model posterior distribution ==#\r\nP = dirichletPosteriorEstimation( errMatTraining, nrRuns, α_ );\r\n\r\n#== use T-Distribution algorithm to estimate the model posterior distribution ==#\r\nP = TDistPosteriorEstimation( errMatTraining, nrRuns );\r\n\r\n\r\n\r\n#== make ensemble prediction ==#\r\nprediction = predictEnsemble( predictionsEval, p );","category":"page"},{"location":"#","page":"-","title":"-","text":"\"\"\"","category":"page"},{"location":"#","page":"-","title":"-","text":"supported problems per algorithm","category":"page"},{"location":"#","page":"-","title":"-","text":"algorithm univariate Classification multivariate Classification univariate Regression multivariate Classification\nbootstrap yes yes yes yes\nbootstrap cor. yes no yes no\ndirichletian yes, only {0,1}-loss yes, only {0,1}-loss no no\nt-distribution yes yes yes yes","category":"page"},{"location":"#","page":"-","title":"-","text":"___","category":"page"},{"location":"#","page":"-","title":"-","text":"supported problems per fine tuning algorithms","category":"page"},{"location":"#","page":"-","title":"-","text":"algorithm univariate Classification multivariate Classification univariate Regression multivariate Classification\nδOptimizationMSE yes no yes no\nδOptimizationHinge yes no no no\nδOptimizationHingeRegularized yes no no no\nδOptimizationMSERegularized yes no yes no","category":"page"},{"location":"#Index-1","page":"-","title":"Index","text":"","category":"section"},{"location":"#","page":"-","title":"-","text":"","category":"page"}]
}
